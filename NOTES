RESEARCH NOTES
  - Think about how to handle dict (e.g. with labels) - what is common to list?
    - Main idea: items carry labels in meta, so labels may or may not be used to organise in container
    - Perhaps just use a list but store labels in meta for use with a dict.
      - Let's start with the ListContainer then build the dict on top of that
     - Might simplify everything.
    - Just realised meta gets lost on unwrap, but need it to carry the label downstream
    - Shold be possible for key to travel arbitrarily downstream
     - perhaps explicitly set the container lens to be labelled
  - Re-organise these notes!
  - Update typing to simplify it, modifying behaviour through lens options.
    - Need to revise some of the below ideas
  - Think more about general container behaviour in light of using source meta
    - Should we have a general container that handles various alignment and puts checks in based on type used?
    - How does this relate to a dict, which is a set that also stores keys to access items.
    - Need to think about USER-INTENDED (or perhaps IMPLIED) alignment:
      - Case of using labels where value changed, loosing meta
       - perhaps if item has no meta but its label had a copy of original meta we can reinstate meta in 
         (new) item where the user would feel they are the same item.
  
  - Use of keys and labels: lens designer can set arbitrary lens options
    - IMPORTANT: When returning items, ensure set_key is called to update cont key.
      - Perhaps could handle this in DictContainer constructor.
    - Think about how best to handle setting a key on a item that was passed
      from user which does not contain its key.
      - On reflection, seems better to wrap in a group, though we could use
        auto_list idea and a wrapper of group: KeyValue(X(is_key) + "==>" +
        Y(type=P)) --> Group(<lens>, type=auto_list)
  - Misc ideas
  - Could we have type=str on container lens rather than combine chars?
  - Group should take only non-typed lens?
  - Create KeyValue lens -> wraps autolist with an is_label
  - Could have containers in container, multiplex store and consume.
  - If any kargs set on a lens, assume is a store using default type of str
  - DEV:TESTS inheritance, makes it difficult to disable tests by changing function
    name.
  - DEV: Commit hooks 
    - Would be good if hook can add prefix to commit message to show test status.
  - Optimisations
    - Concering containers:
      - How to know whether a given lens may modify a container or input
      - How to know efficiently if a lens has modifed a container
        - Dirty flag idea may fail with overwrites by nested lenses
        - Listened objecj sounds good, but how to account for state reset
    - Concerning Rollbackables
      - Find solution to efficient object rollback, avoiding blanket deepcopy - use aspects, perhaps?
      - I think we only need two copies when we re-use the original state, such as in Or
    - Concering meta data
      - It does not make sense for all lens items to carry their input string (e.g. AO) since they do not interleve input with created values.
    - When does a PUT first require a GET:
      - Or cross put
      - Key matching
      - None aligned input
      - ?
      - Could we improve this?
    

Links
-----

http://code.activestate.com/recipes/528934-top-down-recursive-pyparsing-parsers-without-forwa/
http://www.mail-archive.com/python-list@python.org/msg17905.html
/resources/apps/augeas/augeas-git-annotated/lenses/tests/

RESEARCH NOTES
  - Revision of PUT
    - Incremental changes
      - Check all tests are sensible with new PUT (i.e. don't use CREATE).
        before trusting results.
        - Need richer tests to make sure item input is being used correctly AO too simple.
  - Reorganise code:
    - storage.py -> item things, containers, input reader
  - Remember: stuff on stash
  - Use of keys and labels: lens designer can set arbitrary lens options
    - Do I need to rethink lists, too?:
      - In a repeated lens, say, when using meta we know for sure if the
        current concrete item matches our abstract item
        - So with a list or dict, the container will know when to output nothing
          given some concrete input (e.g. when its abstract item has been
          deleted)
        - With position info it would be possible to change keys in-place (in
          concrete) and indeed may make no sense to use concrete input from a
          different item simply because the keys now match - but perhaps not
          always?!?
        - Perhaps maintaince of position reagardless of keys, etc. is a
          potention lens option?
    - When returning items, ensure set_key is called to update cont key.
    - Think about how best to handle setting a key on a item that was passed
      from user which does not contain its key.
      - On reflection, seems better to wrap in a group, though we could use
        auto_list idea and a wrapper of group: KeyValue(X(is_key) + "==>" +
        Y(type=P)) --> Group(<lens>, type=auto_list)
    - Still, during create, we may make a bad choice of several candidates of
      items to put into a given lens, so might be best to let container handle
      put, such that it can flexibly make tentitive puts on certain tokens.
      - Though we can certainly hone our candidate selection based on lens type
      - Correctly handle auto_list in candidate selection.
    - In general, if a container can store items correctly from lenses, it must
      be able to put them back or create them correctly.
  - Could we have type=str on container lens rather than combine chars?
  - Group should take only non-typed lens?
  - Create KeyValue lens
  - Could have containers in container, multiplex store and consume.
  - Find nice way to add simple tracing messages so we can see what's going on
  - If any kargs set on a lens, assume is a store using default type of str
  - Think about how to best implement auto list idea
  - TESTS inheritance, makes it difficult to disable tests by changing function
    name.
  - Commit hooks 
    - Would be good if hook can add prefix to commit message to show test status.
  - Optimisations
    - Concering containers:
      - How to know whether a given lens may modify a container or input
      - How to know efficiently if a lens has modifed a container
        - Dirty flag idea may fail with overwrites by nested lenses
        - Listened objecj sounds good, but how to account for state reset
    - Concerning Rollbackables
      - Find solution to efficient object rollback, avoiding blanket deepcopy - use aspects, perhaps?
      - I think we only need two copies when we re-use the original state, such as in Or
    - Concering meta data
      - It does not make sense for all lens items to carry their input string (e.g. AO) since they do not interleve input with created values.
    - When does a PUT first require a GET:
      - Or cross put
      - Key matching
      - None aligned input
      - ?
      - Could we improve this?
    

Links
-----

http://code.activestate.com/recipes/528934-top-down-recursive-pyparsing-parsers-without-forwa/
http://www.mail-archive.com/python-list@python.org/msg17905.html
/resources/apps/augeas/augeas-git-annotated/lenses/tests/
